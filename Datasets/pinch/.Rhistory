install.packages("gapminder")
install.packages("tidyverse")
library(gapminder)
library(tidyverse)
library(dplyer)
library(dplyr)
library(ggplot2)
head(gapminder)
tail(gapminder)
summary(gapminder)
summary(gapminder)
help("gapminder")
filter(gapminder, year == 2007)
gapminder07 <- filter(gapminder, year == 2007)
head(gapminder07)
summarize(gapminder07, median(lifeExp))
# Median life expectancy (by continent)
by_cont <- group_by(gapminder07, continent)
summarise(by_cont, median(lifeExp))
medL <- summarize(by_cont, median(lifeExp))
plot(medL)
filter(gapminder07,continent == "Oceania")
medL
medL <- gapminder %>%
filter(year == 2007) %>%
group_by(continent) %>%
summarise(medLifeExp = median(lifeExp))
medL
medL_dplyr <- gapminder %>%
filter(year == 2007) %>%
group_by(continent) %>%
summarise(medLifeExp = median(lifeExp))
medLA <- gapminder %>%
filter(continent == "Africa") %>%
group_by(country) %>%
summarise(medLifeExp = median(lifeExp))
medLA
filter(medLA,medLifeExp<40)
filter(medLA,medLifeExp>60)
cc = c("Angola","Guinea-Bissau","Sierra Leone",
"Mauritius","Reunion","Tunisia",
"Mexico") # Mexico for comparison
gapminder %>%
filter(country %in% cc) %>%
ggplot(aes(x=year,y=lifeExp,color=country)) +
geom_point() +
geom_smooth(method = "lm")
gapminder %>%
filter(continent == "Oceania") %>%
ggplot(aes(x=year,y=lifeExp,color=country)) +
geom_point() +
geom_smooth(method = "loess", span=3/4)
###########################################
# Life expectancy versus per-capita GDP
###########################################
qplot(gdpPercap,lifeExp,data=gapminder07)
qplot(gdpPercap,lifeExp,data=gapminder07,color = continent)
ggplot(gapminder07, aes(x=gdpPercap,y=lifeExp,color=continent)) +
geom_point() +
geom_smooth(method = "lm", se=FALSE)
save.image("C:/Users/Sidi/Desktop/Lab 1/Lab1_Env.RData")
library(fda)
library(fda.usc)
data("tecator")
x = tecator$absorp.fdata$data
View(x)
dim(x)
raw_tpts = tecator$absorp.fdata$argvals
n_tpts = length(raw_tpts)
n_tpts
tpts = seq(0, 1, length.out = tpts.no)
tpts = seq(0, 1, length.out = n_tpts)
tpts
n = nrow(x)
split.rate = 0.8
TrainData = x[1:round(n*split.rate),]
TestData = x[-(1:round(n*split.rate)),]
?basis.rep
tpts.raw = tecator$absorp.fdata$argvals
tpts.no = length(tpts.raw)
tpts = seq(0, 1, length.out = tpts.no)
?create.bspline.basis
nbasis = 150
norder = 4
data.basis = create.bspline.basis(rangeval = range(tpts), nbasis, norder)
Lfdobj <- int2Lfd(max(0, norder-2))
# Get basis functions evaluated at all observed time stamps
basis_fct = t(eval.basis(tpts, data.basis))
basis.lambda.select <- function(data.basis, Lfdobj, tpts, data.y){
lam.candidate <- 0:15
nlam = length(lam.candidate)
gcvsave = rep(NA,nlam)
for (i in 1:nlam) {
lambda  = lam.candidate[i]
data.fdPar = fdPar(data.basis, Lfdobj, lambda)
smoothlist = smooth.basis(tpts, t(data.y), data.fdPar)
gcvsave[i] = sum(smoothlist$gcv)
}
lambda <- lam.candidate[which.min(gcvsave)]
return(lambda)
}
basis.lambda = basis.lambda.select(data.basis, Lfdobj, tpts, x)
data.basis
nbasis = 80
norder = 4
data.basis = create.bspline.basis(rangeval = range(tpts), nbasis, norder)
Lfdobj <- int2Lfd(max(0, norder-2))
# Get basis functions evaluated at all observed time stamps
basis_fct = t(eval.basis(tpts, data.basis))
# Select the best lambda for basis representation
basis.lambda.select <- function(data.basis, Lfdobj, tpts, data.y){
lam.candidate <- 0:15
nlam = length(lam.candidate)
gcvsave = rep(NA,nlam)
for (i in 1:nlam) {
lambda  = lam.candidate[i]
data.fdPar = fdPar(data.basis, Lfdobj, lambda)
smoothlist = smooth.basis(tpts, t(data.y), data.fdPar)
gcvsave[i] = sum(smoothlist$gcv)
}
lambda <- lam.candidate[which.min(gcvsave)]
return(lambda)
}
basis.lambda = basis.lambda.select(data.basis, Lfdobj, tpts, x)
basis.lambda
data.fdPar = fdPar(data.basis, Lfdobj, lambda=basis.lambda)
data.smooth = smooth.basis(tpts, t(data.y), data.fdPar)
data.fd = data.smooth$fd
data.fd.coef = t(data.smooth$fd$coef)
basis.lambda = basis.lambda.select(data.basis, Lfdobj, tpts, x)
data.fdPar = fdPar(data.basis, Lfdobj, lambda=basis.la
data.smooth = smooth.basis(tpts, t(x), data.fdPar)
data.fd = data.smooth$fd
data.fd = data.smooth$fd
data.smooth = smooth.basis(tpts, t(x), data.fdPar)
data.fd = data.smooth$fd
data.fd.coef = t(data.smooth$fd$coef)
split.rate = 0.8
TrainData = x[1:round(n*split.rate),]
TestData = x[-(1:round(n*split.rate)),]
## FPCA
train.fpca = pca.fd(data.fd, nharm = 15, harmfdPar = data.fdPar)
# Get the FPCs
train.fpca.harms = train.fpca$harmonics$coefs
# Get the est. mean curve for tpts
train.fpca.meanfd = eval.fd(tpts, train.fpca$meanfd)
# Get the FPC socres
train.fpca.scores = train.fpca$scores
train.fpca.scores
dim(train.fpca.scores)
train.fpca.scores[1,]
y_obs_fd_coef = y_train %*% t(train.fpca.harms[, 1:no.fpc]) #no_test.set x nbasis
y_obs_fd = fd(t(y_obs_fd_coef), data.basis, data.fd$fdnames)
y_centered_obs = eval.fd(tpts, y_obs_fd) #tpts.no x no_test.set
y_train_obs = t(y_centered_obs + matrix(rep(train.fpca.meanfd, length(train.no)),
ncol = length(train.no))) #no_test.set x tpts.no
plot(train.fpca.harms)
train.fpca.harms
head(train.fpca.harms)
plot.pca.fd(train.fpca)
op <- par(mfrow=c(3,3))
plot.pca.fd(train.fpca, cex.main=0.9)
op <- par(mfrow=c(2,2))
plot.pca.fd(train.fpca, cex.main=0.9)
op <- par(mfrow=c(2,2))
plot.pca.fd(train.fpca, cex.main=0.9)
train.fpca.harms = train.fpca$harmonics$coefs
# Get the est. mean curve for tpts
train.fpca.meanfd = eval.fd(tpts, train.fpca$meanfd)
# Get the FPC socres
train.fpca.scores = train.fpca$scores
# Variance explained by top FPCs
train.fpca.var = vector("logical")
for (i in 1:length(train.fpca$varprop)){
train.fpca.var[i] = sum(train.fpca$varprop[1:i])/sum(train.fpca$varprop)
}
# Plot FPCs
op <- par(mfrow=c(2,2))
plot.pca.fd(train.fpca, cex.main=0.9)
plot.pca.fd(train.fpca, cex.main=0.9)
par(mfrow=c(1,1,))
par(mfrow=c(1,1))
plot.pca.fd(train.fpca, cex.main=
0.9)
train.fpca.harms[1,]
train.fpca.harms[,1]
train.fpca$harmonics
train.fpcs = fd(train.fpca.harms, data.basis, data.fd$fdnames)
plot(train.fpcs)
train.fpcs
plot.fd(train.fpcs)
plot.fd(train.fpcs[1])
train.fpca.scores[1:5,]
train.fpca = pca.fd(data.fd, nharm = 1, harmfdPar = data.fdPar)
# Get the FPCs
train.fpca.harms = train.fpca$harmonics$coefs
train.fpcs = fd(train.fpca.harms, data.basis, data.fd$fdnames)
# Get the est. mean curve for tpts
train.fpca.meanfd = eval.fd(tpts, train.fpca$meanfd)
# Get the FPC socres
train.fpca.scores = train.fpca$scores
# Variance explained by top FPCs
train.fpca.var = vector("logical")
for (i in 1:length(train.fpca$varprop)){
train.fpca.var[i] = sum(train.fpca$varprop[1:i])/sum(train.fpca$varprop)
}
plot.fd(train.fpcs[1])
train.fpca = pca.fd(data.fd, nharm = 1, harmfdPar = data.fdPar)
# Get the FPCs
train.fpca.harms = train.fpca$harmonics$coefs
train.fpcs = fd(train.fpca.harms, data.basis, data.fd$fdnames)
# Get the est. mean curve for tpts
train.fpca.meanfd = eval.fd(tpts, train.fpca$meanfd)
# Get the FPC socres
train.fpca.scores = train.fpca$scores
# Variance explained by top FPCs
train.fpca.var = vector("logical")
for (i in 1:length(train.fpca$varprop)){
train.fpca.var[i] = sum(train.fpca$varprop[1:i])/sum(train.fpca$varprop)
}
# Plot FPCs
op <- par(mfrow=c(2,2))
plot.pca.fd(train.fpca, cex.main=0.9)
plot.fd(train.fpcs[1])
op <- par(mfrow=c(1,1))
plot.pca.fd(train.fpca, cex.main=0.9)
train.fpca.harms
train.fpcs = fd(train.fpca.harms, data.basis, data.fd$fdnames)
train.fpcs
# Plot FPCs
plot.fd(train.fpcs[1])
train.fpca.harms
# Plot FPCs
plot(train.fpcs[1])
# Plot FPCs
plot.fd(train.fpcs[1])
train.fpcs
basis_fct
dim(train.fpca.harms)
dim(badid_fct)
dim(basis_fct)
# Plot FPCs
fpc = t(train.fpca.harms) %*% basis_fct
plot(fpc)
fpc
# Plot FPCs
fpc = t(t(train.fpca.harms) %*% basis_fct)
plot(fpc)
plot.pca.fd(data.fd, cex.main=0.9)
plot.pca.fd(train.fpca, cex.main=0.9)
train.fpca.harms
train.fpca$harmonics
plot.fd(train.fpca$harmonics)
fpc = eval.fd(tpts, train.fpca$harmonics)
fpc
plot(tpts, fpc)
fpc = eval.fd(tpts, train.fpca$harmonics)+eval.fd(tpts, train.fpca.meanfd)
train.fpca.meanfd
fpc = eval.fd(tpts, train.fpca$harmonics)+train.fpca.meanfd
plot(tpts, fpc)
plot.pca.fd(train.fpca, cex.main=0.9)
daybasis65 <- create.fourier.basis(c(0, 365), nbasis=65, period=365)
harmaccelLfd <- vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))
harmfdPar     <- fdPar(daybasis65, harmaccelLfd, lambda=1e5)
daytempfd <- smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"],
daybasis65, fdnames=list("Day", "Station", "Deg C"))$fd
daytemppcaobj <- pca.fd(daytempfd, nharm=4, harmfdPar)
#  plot harmonics, asking before each new page after the first:
plot.pca.fd(daytemppcaobj)
par(op)
daybasis365 = create.fourier.basis(c(0,365),365)
# harmonic acceleration differential operator
harmLfd = vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))
tempfdPar = fdPar(daybasis365,harmLfd,1e4)
tempfd = smooth.basis(1:365,daily$tempav,tempfdPar)
quartz()
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
plot(tempfd$fd,xlab='day',ylab='temperature',cex.lab=1.5,cex.axis=1.5)
daily$place
length(daily$place)
# calculate the variance-covariance of the functional data
tempvar = var.fd(tempfd$fd)
tvvals = eval.bifd(1:365,1:365,tempvar)
quartz()
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
contour(1:365,1:365,tvvals,xlab='day',ylab='day',cex.lab=1.5,cex.axis=1.5)
library(fields)
quartz()
image.plot(1:365,1:365,tvvals,xlab='day',ylab='day',cex.lab=1.5,cex.axis=1.5)
temp.cor = cor.fd(1:365,tempfd$fd)
temppca = pca.fd(tempfd$fd,nharm=4)
names(temppca)
temppca$varprop
#temppca$values are the eigenvalues
source('~/.active-rstudio-document', echo=TRUE)
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
matplot(1:365,harmvals,xlab='day',ylab='PCs',
lwd=4,lty=1,cex.lab=2.5,cex.axis=2.5,type='l')
legend(0,-0.07,c('PC1','PC2','PC3','PC4'),col=1:4,lty=1,lwd=5)
title('Temperature Principle Component Functions')
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
matplot(1:365,harmvals,xlab='day',ylab='PCs',
lwd=4,lty=1,cex.lab=2.5,cex.axis=2.5,type='l')
legend(0,-0.07,c('PC1','PC2','PC3','PC4'),col=1:4,lty=1,lwd=5)
title('Temperature Principle Component Functions')
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
matplot(1:365,harmvals,xlab='day',ylab='PCs',
lwd=4,lty=1,cex.lab=2.5,cex.axis=2.5,type='l')
legend(0,-0.07,c('PC1','PC2','PC3','PC4'),col=1:4,lty=1,lwd=5)
title('Temperature Principle Component Functions')
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
matplot(1:365,harmvals,xlab='day',ylab='PCs',
lwd=4,lty=1,cex.lab=2.5,cex.axis=2.5,type='l')
legend(0,-0.07,c('PC1','PC2','PC3','PC4'),col=1:4,lty=1,lwd=5)
title('Temperature Principle Component Functions')
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
matplot(1:365,harmvals,xlab='day',ylab='PCs',
lwd=4,lty=1,cex.lab=2.5,cex.axis=2.5,type='l')
legend(0,-0.07,c('PC1','PC2','PC3','PC4'),col=1:4,lty=1,lwd=5)
title('Temperature Principle Component Functions')
harmfd = temppca$harmonics
harmvals = eval.fd(1:365,harmfd)
dim(harmvals) # The top 4 FPCs
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
matplot(1:365,harmvals,xlab='day',ylab='PCs',
lwd=4,lty=1,cex.lab=2.5,cex.axis=2.5,type='l')
title('Temperature Principle Component Functions')
par(mfrow=c(1,1),mar = c(8, 8, 4, 2))
plot(1:365,harmvals[,2],xlab='day',ylab='PCs',
lwd=4,lty=1,cex.lab=2,cex.axis=2,type='l')
plot.pca.fd(daytemppcaobj, cex.main=0.9)
plot.fd(train.fpcs[1])
plot.fd(train.fpca$harmonics)
plot.fd(train.fpcs[1])
plot(tpts, fpc)
plot(tpts, fpc, type = "l")
a
fpc = eval.fd(tpts, train.fpca$harmonics)
plot(tpts, fpc, type = "l")
train.fpca.scores
nbasis = 30
norder = 4
data.basis = create.bspline.basis(rangeval = range(tpts), nbasis, norder)
Lfdobj <- int2Lfd(max(0, norder-2))
# Get basis functions evaluated at all observed time stamps
basis_fct = t(eval.basis(tpts, data.basis))
# Select the best lambda for basis representation
basis.lambda.select <- function(data.basis, Lfdobj, tpts, data.y){
lam.candidate <- 0:15
nlam = length(lam.candidate)
gcvsave = rep(NA,nlam)
for (i in 1:nlam) {
lambda  = lam.candidate[i]
data.fdPar = fdPar(data.basis, Lfdobj, lambda)
smoothlist = smooth.basis(tpts, t(data.y), data.fdPar)
gcvsave[i] = sum(smoothlist$gcv)
}
lambda <- lam.candidate[which.min(gcvsave)]
return(lambda)
}
basis.lambda = basis.lambda.select(data.basis, Lfdobj, tpts, x)
data.fdPar = fdPar(data.basis, Lfdobj, lambda=basis.lambda)
data.smooth = smooth.basis(tpts, t(x), data.fdPar)
data.fd = data.smooth$fd
data.fd.coef = t(data.smooth$fd$coef)
# Get training set & test set
split.rate = 0.8
TrainData = x[1:round(n*split.rate),]
TestData = x[-(1:round(n*split.rate)),]
## FPCA
train.fpca = pca.fd(data.fd, nharm = 1, harmfdPar = data.fdPar)
# Get the FPCs
train.fpca.harms = train.fpca$harmonics$coefs
#train.fpcs = fd(train.fpca.harms, data.basis, data.fd$fdnames)
# Get the est. mean curve for tpts
train.fpca.meanfd = eval.fd(tpts, train.fpca$meanfd)
# Get the FPC socres
train.fpca.scores = train.fpca$scores
# Variance explained by top FPCs
train.fpca.var = vector("logical")
for (i in 1:length(train.fpca$varprop)){
train.fpca.var[i] = sum(train.fpca$varprop[1:i])/sum(train.fpca$varprop)
}
# Plot FPCs
plot.fd(train.fpca$harmonics)
train.fpca.scores
cc = c(34, 42, 43, 98, 118, 124, 138, 139, 184, 186, 203)
train.fpca.scores[cc]
save.image("C:/Users/Sidi/Desktop/FAE_local/tecator/tecator_FPCA_env.RData")
library(tidyverse)
library(ggplot2)
library(dplyr)
data("mpg")
ggplot(data=mpg) + geom_point(mapping = aes(x=displ, y=hwy, color=class))
ggplot(data=mpg) + geom_point(mapping = aes(x=displ, y=hwy, shape=class))
ggplot(data=mpg, mapping = aes(x=displ, y=hwy)) + geom_point()
ggplot() + geom_point(data=mpg, mapping=aes(x=displ, y=hwy))
ggplot(data=mpg, aes(x=displ, y=hwy, color=class)) +
geom_point() + geom_smooth()
ggplot(data=mpg, aes(x=displ, y=hwy, color=class)) +
geom_point() + geom_smooth() +
facet_wrap(-class, nrow=2)
ggplot(data=mpg, aes(x=displ, y=hwy, color=class)) +
geom_point() + geom_smooth() +
facet_wrap(- class, nrow=2)
ggplot(data=mpg) + geom_point(mapping=aes(x=displ, y=hwy, color=class)) +
facet_grid(drv - cyl)
ggplot(data=mpg, aes(x=displ, y=hwy, color=class)) +
geom_point() + geom_smooth() +
facet_wrap(class, nrow=2)
ggplot(data=mpg, aes(x=displ, y=hwy, color=class)) +
geom_point() + geom_smooth() +
facet_wrap(vars(class), nrow=2)
ggplot(data=mpg, aes(x=displ, y=hwy, color=class)) +
geom_point() + geom_smooth() +
facet_wrap(vars(class))
ggplot(data=mpg) + geom_point(mapping=aes(x=displ, y=hwy, color=class)) +
facet_grid(drv - cyl)
ggplot(data=mpg) + geom_point(mapping=aes(x=displ, y=hwy, color=class)) +
facet_grid(vars(drv - cyl))
ggplot(data=mpg) + geom_point(mapping=aes(x=displ, y=hwy, color=class)) +
facet_grid(vars(drv - cyl))
ggplot(data=mpg) + geom_point(mapping=aes(x=displ, y=hwy, color=class)) +
facet_grid(vars(cyl, drv))
ggplot(data=mpg) + geom_point(mapping=aes(x=displ, y=hwy, color=class)) +
facet_grid(vars(drv, cyl))
ggplot(data=mpg) + geom_point(mapping=aes(x=displ, y=hwy, color=class)) +
facet_grid(drv ~ cyl)
ggplot(data=mpg, aes(x=displ, y=hwy, color=class)) +
geom_point() + geom_smooth() +
facet_wrap(~ class, nrow=2)
a
remove.packages("rmarkdown")
install.packages("rmarkdown")
install.packages("rmarkdown")
library(fda)
CanadianWeather$dailyAv
data = CanadianWeather$dailyAv
dim(data)
data("pinch")
pinch
dim(pinch)
pinchtime
data("refinery")
pinchraw
dim(pinchraw)
dim(pinch)
pinch
setwd("C:/Users/Sidi/Desktop/FAE/FAE/Datasets/pinch")
write.table(pinch, file="pinch.csv", row.names = F)
write.csv(pinch, file="pinch.csv", row.names = F)
write.csv(pinch_raw, file="pinch_raw.csv", row.names = F)
write.csv(pinchraw, file="pinchraw.csv", row.names = F)
write.csv(pinchtime, file="pinch_tpts.csv", row.names = F)
pinchtime
write.csv(t(pinch), file="pinch.csv", row.names = F)
write.csv(t(pinchraw), file="pinchraw.csv", row.names = F)
